# 38. Семантика памяти. Отслеживание изменений данных в кэш-памяти. 

## Семантика памяти

### Строгая согласованность

**Самая простая модель – строгая согласованность.** В такой системе при любом считывании из адреса X всегда возвращается значение самой последней записи в X. Она может быть реализована только следующим образом: должен быть один модуль памяти, который обслуживает все запросы по мере поступления, без кэш-памяти, без дублирования данных. Что в свою очередь очень сильно замедляет работу памяти.

### Согласованность по последовательности (секвенциальная состоятельность)

**Согласованность по последовательности** – при наличии нескольких запросов на чтение и запись аппаратное обеспечение определяет порядок всех запросов, но все процессоры наблюдают одну и ту последовательность запросов. Согласованность по последовательности гарантирует единый глобальный порядок записей, который виден всем процессорам. Если один процессор видит, что записано число 3, то и остальные процессоры видят то же самое. Согласованность по последовательности очень полезна. Если несколько событий совершаются одновременно, существует определенный порядок, в котором эти события происходят, (сам порядок может определяться случайно) и все процессоры наблюдают тот же самый порядок.

### Процессорная согласованность

**Процессорная согласованность** – более проигрышная модель, но зато ее легче реализовать на больших мультипроцессорах.      
Она имеет два свойства: 

1. Все процессоры воспринимают записи любого процессора в том порядке, в котором они начинаются; 
2. Все процессоры видят записи в слово памяти в том порядке, в котором они происходят. 

В *первом пункте* говорится, что если процессор 1 начинает запись значения 1А, 1В, 1С в какое-то место в памяти именно в таком порядке, то все другие процессоры видят эти записи в таком же порядке. *Второй пункт* нужен, чтобы каждое слово в памяти имело определенное недвусмысленное значение после того, как процессор совершил несколько записей в это слово, а затем остановился. Все должны воспринимать последнее значение.

### Слабая согласованность

При использовании модели слабой согласованности записи, произведенные одним процессором, воспринимаются не по порядку. Один процессор может увидеть 1А, 1В, а другой 1В, 1А. Чтобы внести порядок в этот хаос, в памяти содержатся элементы синхронизации или операции синхронизации. Когда выполняется синхронизация, все незаконченные записи завершаются, а новые не могут начаться пока не будут завершены все начатые и не будет проведена синхронизация.

### Свободная согласованность

При свободной согласованности используется нечто похожее на критические секции программы. Идея состоит в следующем. Если процесс выходит за пределы критической области, это не значит, что все записи должны немедленно завершиться. Требуется только, чтобы все записи были завершены до того, как процесс снова войдет в эту критическую область.

В такой модели операция синхронизации разделяется на две разные операции. Чтобы считать или записать общую переменную, процессор (т.е. его ПО) сначала должно выполнить операцию **acquire** над переменной синхронизации, чтобы получить монопольный доступ к общим разделяемым данным. Затем процессор может использовать эти данные по своему усмотрению, а затем процессор выполняет операцию **release** над переменной синхронизации, чтобы показать, что он завершил работу.

## Отслеживание изменений данных в кэш-памяти

Предположим, что память согласована по последовательности. Процессор 1 содержит в своей кэш-памяти строку. Процессор 2 пытается считать данные из этой же строки. Если не оговорено иное, процессор 2 получает в свою кэш-память копию строки. В этом нет ничего страшного, пока процессор 1 не внес изменения в строку кэш-памяти. В таком случае процессор 2 имеет устаревший данные, и нарушается принцип согласования данных по последовательности.  Такая проблема называется непротиворечивостью кэшей. алгоритмы, позволяющие разрешить эту проблему  называются протоколами когерентности кэширования.   ------кэш-память с отслеживанием------стратегией обновления и стратегией признания данных недействительными