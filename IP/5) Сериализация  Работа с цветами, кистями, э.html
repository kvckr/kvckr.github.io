<html>
<head>
  <title>5) Сериализация / Работа с цветами, кистями, эффектами и прозрачностью в WPF</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/274061; Windows/6.3.9600;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="925"/>
<h1>5) Сериализация / Работа с цветами, кистями, эффектами и прозрачностью в WPF</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><strong>Сериализация</strong></div><div>Сериализация представляет собой процесс преобразования объекта в поток байтов для хранения объекта или передачи его в память, базу данных или файл. Ее основное назначение —сохранить состояние объекта для того, чтобы иметь возможность воссоздать его при необходимости. Обратный процесс называется десериализацией.</div><div>Контракт данных – это тип (класс или структура), объект которого описывает инф фрагмент(фрагмент мб сохранен, а затем восстановлен).</div><div>Основным форматом хранения контрактов д явлxml. У атрибута [DataMember] есть св-во Name,order(порядок записи э контракта), isrequired (обязательный э для записи), EmitDefaultValue(нужна ли запись значения по умолчанию для э). Если контракт явл</div><div>коллекцией объектов (класс Group), он маркируется атрибутом [CollectionDataContract]/ Применимы атрибуты [OnSerializing], [OnSerialized], [OnDeserializing], [OnDeserialized].Атрибут  [KnownType] – контракт планируется десериальзовать в объекты потомков своего типа.Если контракт является коллекцией объектов (как класс Group), он маркируется атрибутом [CollectionDataContract]. Кроме этого, для методов контракта данных применимы атрибуты [OnSerializing], [OnSerialized], [OnDeserializing], [OnDeserialized].</div><div>Для сериализации контракта данных используются классы:</div><div>1.DataContractSerializer сериализует контракт;</div><div>2.NetDataContractSerializer сериализует данные и тип контракта;</div><div>3.DataContractJsonSerializer сериализует контракта в формате JSON.Классы, связанные с сериализацией времени выполнения, размещены в пространствах имѐн с префиксом System.Runtime.Serialization.</div><div>Сериализация времени выполнения применима только к объектам сериализуемых типов. Сериализуемый тип – это тип, помеченный атрибутом [Serializable] у которого все поля имеют сериализумый тип. Все базовые типы платформы .NET являются сериализуемыми. Если планируется сериализация объекта group, необходимо добавить атрибут [Serializable] к классам Group и Student. Сериализация некоторых полей может не иметь смысла (например, эти поля вычисляются при работе с объектом или хранят конфиденциальные данные). Для таких полей можно применить атрибут [NonSerialized].Сериализуемые типы можно сохранить в поток в различных форматах. Платформа .NET имеет классы, поддерживающие двоичный формат и формата SOAP. Можно создать свой формат. Осуществим сериализацию объекта group в двоичном формате. Используем для этого экземплярный метод Serialize() класса BinaryFormatter.АльтерIDeserializationCallbackявлатрибуты[OnSerializing], [OnSerialized], [OnDeserializing], [OnDeserialized], применимыекметодам. Помеченные методы вызываются авто до и после  сериализации или десериализации. Метод, должен принимать в качестве аргумента объект класса StreamingContext3 и не возвращать значений. Каждый из атрибутов может применяться только к одному методу в типе. Если не устраивает способ организации потока сериализуемых д, можно повлиять на этот процесс, реализуя в сериализуемом типе интерфейс ISerializable. Интерфейс позволяет выполнить любые действия, связанные с формированием данных для сохранения. Метод GetObjectData() вызывается CLR авто привыполнении сериализации. Реализация метода-заполнение объекта SerializationInfo набором данных вида«ключ-значение», которые (обычно) соответствуют полям сохраняемого объекта. Класс SerializationInfo содержит перегруженный метод AddValue(), набор методов вида GetПримитивныйТип(), а также свойства для указания имени типа и сборки сериализуемого  объекта. Если тип реализует интерфейс ISerializable, он должен содержать специальный private-конструктор, который будет вызывать CLR после выполнения десериализации. Конструктор должен иметь параметр типа SerializationInfo и StreamingContext.</div><div><hr/><b>Работа с цветами, кистями, эффектами и прозрачностью в WPF</b><br/></div><div>WPF позволяет работать с двумя цветовыми моделями:<br/>
1. RGB – распространённая цветовая модель, в которой каждый компонент цвета (красный, зелёный, синий) представлен одним байтом.<br/>
2. scRGB – в этой модели каждый компонент цвета (альфа-канал, красный, зелёный, синий) представлен с помощью 16- или 32-битных вещественных чисел в диапазоне от 0 до 1.<br/>
Структура System.Windows.Media.Color хранит информацию о цвете. Свойства позволяют прочитать или задать отдельную цветовую компоненту , а статические методы – создать цвет на основе компонент:<br/>
Color c1 = Color.FromRgb(10, 20, 30)</div><div>Color c2 = Color.FromArgb(250, 10, 20, 32);<br/>
Color c4 = (c1 + c2)*2; </div><div>byte red = c4.R;<br/>
Класс System.Windows.Media.Colors содержит набор именованных цветов в виде статических свойств для чтения. Класс System.Windows.SystemColors предоставляет аналогичный набор для стандартных цветов системы:<br/>
Color c1 = Colors.IndianRed;</div><div>Color c2 = SystemColors.ControlColor;<br/>
При установке цвета в разметке XAML применяются следующие форматы:<br/>
Имя-цвета – одно из имён свойств в классе Colors;<br/>
&lt;Button Background=&quot;Red&quot; /&gt; &lt;Button Background=&quot;#64A&quot; /&gt;<br/>
Кисть – это объект, используемый для заполнения фона, переднего плана, границы, линии. Любая кисть является потомком абстрактного класса System.Windows.Media.Brush. Имеется несколько стандартных классов<br/>
кистей:<br/>
1. SolidColorBrush – закрашивает область сплошным цветом;<br/>
2. LinearGradientBrush – закрашивает область, используя линейное<br/>
градиентное заполнение, изображающее переход от одного цвета к другому;<br/>
3. RadialGradientBrush – рисует область, используя радиальный градиент.<br/>
4 ImageBrush – рисует область, используя изображение, которое может<br/>
растягиваться, масштабироваться или многократно повторяться.<br/>
5. VisualBrush – заполняет область, используя объект Visual.<br/>
6. DrawingBrush – рисует область, используя объект Drawing.<br/>
WPF поддерживает применение к элементам эффектов, таких как размытие или отбрасывание тени. Эффекты описываются классами, унаследованными от System.Windows.Media.Effects.Effect: BlurEffect – эффект размытия;<br/>
DropShadowEffect – эффект тени; ShaderEffect –пиксельные шейдеры.<br/>
&lt;Button.Effect&gt;<br/>
&lt;BlurEffect Radius=&quot;2&quot; RenderingBias=&quot;Quality&quot; /&gt;<br/>
&lt;/Button.Effect&gt;<br/>
В WPF поддерживается истинная прозрачность. Каждый элемент и кисть содержат свойство Opacity, определяющее степень прозрачности и принимающее вещественные значения из диапазона [0, 1], Например, Opacity=0.9 создаёт эффект 90% видимости и 10% прозрачности. Применение OpacityMask с кистями, содержащими градиентный переход от сплошного к прозрачному цвету создаёт эффект постепенного «исчезновения» поверхности. </div></div>
</div></body></html> 