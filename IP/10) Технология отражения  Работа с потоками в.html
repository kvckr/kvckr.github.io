<html>
<head>
  <title>10) Технология отражения / Работа с потоками выполнения</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/274061; Windows/6.3.9600;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="940"/>
<h1>10) Технология отражения / Работа с потоками выполнения</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><b>Технология отражения</b><div>При создании сборки в неё помещаются метаданные, которые являются описанием всех типов в сборке и их элементов. Программист может работать с метаданными, используя специальный механизм, называемый отражением (reflection). Главные элементы, которые необходимы для использования возможностей отражения, – это класс System.Type1 и типы из пространств имён System.Reflection и System.Reflection.Emit. Класс Type служит для хранения информации о типе.<br/>
Существует несколько способов получить объект этого класса: </div><div>1. Вызвать у объекта метод GetType().присутствует у любого объекта:<br/>
Foo foo = new Foo(); /* Foo – это некий класс */ Type t = foo.GetType();<br/>
2. Использовать статический метод Type.GetType(), которому передаётся имя типа в виде строки. Type t1 = Type.GetType(&quot;System.Int32&quot;); Type t2 = Type.GetType(&quot;SomeNamespace.Foo, MyAssembly&quot;);<br/>
3. Использовать операцию C# typeof: Type t = typeof (Foo); Операцию typeof можно применять к массивам и универсальным шаблонам. Причём в последнем случае допускается использовать как сконструированный тип, так и исходный тип-шаблон.<br/>
Type t1 = typeof (int[]); Type t2 = typeof (char[,]); Type t3 = typeof (List&lt;int&gt;); //<br/>
сконструированный тип ;Type t4 = typeof (List&lt;&gt;); // универсальный тип<br/>
Свойства класса Type позволяют узнать имя типа, имя базового типа, является ли тип универсальным, в какой сборке он размещается и другую информацию. Кроме этого, Type имеет специальные методы, возвращающие данные о полях типа,<br/>
свойствах, событиях, методах и их параметрах. Информация об элементах типа хранится в объектах классов FieldInfo, PropertyInfo, MethodInfo и т. п. Эти классы находятся в пространстве имён System.Reflection.Составом получаемой информации можно управлять, передавая в Get-методы дополнительные флаги System.Reflection.BindingFlags (var bf = BindingFlags.Public)(метода стр 100). Пространство имён System.Reflection содержит типы для получения ин- формации и манипулирования сборкой и модулем сборки. При помощи класса Assembly можно получить информацию о сборке, при помощи класса Module – о модуле. Продемонстрируем пример работы с классами Assembly и Module:<br/>
Assembly assembly = Assembly.GetExecutingAssembly();<br/>
Console.WriteLine(assembly.FullName);<br/>
foreach (Module module in assembly.GetModules())<br/>
{<br/>
Console.WriteLine(module.FullyQualifiedName);<br/>
foreach (Type type in module.GetTypes())<br/>
{<br/>
Console.WriteLine(type.FullName);<br/>
}<br/>
} </div><div><hr/><b>Работа с потоками выполнения</b></div><div>Платформа .NET даёт полноценную поддержку для создания многопоточных приложений. Исполняющая среда имеет особый модуль, ответственный за организацию многопоточности, но в основном работа модуля опирается на функции многопоточности операционной системы. Основные классы, предназначенные для поддержки многопоточности,сосредоточены в пространстве имён System.Threading. На платформе .NET каждый поток выполнения (thread) представлен объектом класса Thread. Для организации собственного потока необходимо создать объект этого класса. Класс Thread имеет четыре перегруженные версии конструктора:<br/>
public Thread(ThreadStart start);</div><div>public Thread(ThreadStart start, int maxStackSize);</div><div>public Thread(ParameterizedThreadStart start);</div><div>public Thread(ParameterizedThreadStart start, int maxStackSize);</div><div>В качестве 1 аргумента конструктору передаётся делегат, инкапсулирующий метод, выполняемый в потоке. Доступно два типа делегатов: 2 позволяет при запуске метода передать ему данные в виде объекта: public delegate<br/>
void ThreadStart(); public delegate void ParameterizedThreadStart(object obj);<br/>
Создание потока не подразумевает его автоматического запуска. Для запуска потока требуется вызвать метод Start() (перегруженная версия метода получает объект, передаваемый как аргумент методу потока).<br/>
var th = new Thread(DoSomeWork); th.Start();<br/>
Рассмотрим основные свойства класса Thread:<br/>
1. CurrentThread возвращает объект, представляющий текущий поток.<br/>
2. Свойство Name служит для назначения потоку имени.<br/>
3. Целочисленное свойство для чтения ManagedThreadId возвращает уни-<br/>
кальный числовой идентификатор управляемого потока.<br/>
4. Свойство для чтения ThreadState, позволяет получить состояние потока.<br/>
5. Булево свойство IsAlive позволяет определить, выполняется ли поток.<br/>
6. Свойство Priority управляет приоритетом выполнения потока относи-<br/>
тельно текущего процесса.<br/>
7. Булево свойство IsBackground позволяет сделать поток фоновым. </div><div>Среда исполнения .NET разделяет все потоки на фоновые и основные. Процесс не мо- жет завершиться, пока не завершены все его основные потоки. Метод Suspend() вызывает приостановку потока, метод Resume() возобновляет ра- боту потока. Статический метод Sleep() приостанавливает выполнение текущего потока на указанное количество миллисекунд или значение TimeSpan. Статический метод Yield() передаёт управление следующему ожидающему потоку системы. Метод Join() позволяет дождаться завершения работы того потока, у которого вызывается. Для завершения работы выбранного потока используется метод Abort(). Данный метод генерирует специальное исключение ThreadAbortException. Создание отдельного потока – это довольно «затратная» операция с точки зрения расхода времени и памяти. Для уменьшения издержек, связанных с созданием потоков, платформа .NET поддерживает специальный механизм, называе- мый пул потоков. Пул состоит из двух основных элементов: очереди методов и рабочих потоков. Характеристикой пула является его ёмкость – максимальное число рабочих потоков. При работе с пулом метод сначала помещается в очередь. Если у пула есть свободные рабочие потоки, метод извлекается из очереди и направляется свободному потоку для выполнения. Если свободных потоков нет, но ёмкость пула не достигнута, для обслуживания метода формируется но- вый рабочий поток. Однако этот поток создаётся с задержкой в полсекунды. Если за это время освободится какой-либо из рабочих потоков, то он будет назначен на выполнение метода, а новый рабочий поток создан не будет. Важным нюан- сом является то, что несколько первых рабочих потоков в пуле создаётся без полусекундной задержки.<br/>
Для работы с пулом используется статический класс ThreadPool. Метод SetMaxThreads() позволяет изменить ёмкость пула. Метод SetMinThreads() устанавливает количество рабочих потоков, создаваемых без задержки. Для помещения метода в очередь пула служит метод QueueUserWorkItem().</div></div>
</div></body></html> 