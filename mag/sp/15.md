---
layout: default
title: Порядок работы shell - интерактивный (диалоговый) режим, выполнение сценариев, организация ввода-вывода. Переменные shell (в т.ч. области видимости, экспорт), типы данных. Управление выполнением сценария shell (переходы, ветвления, циклы). Арифметические и логические операции в shell. Управление выполнением внешних программ, взаимодействие с процессами и системой в сценариях shell.
---

# 15. Порядок работы shell - интерактивный (диалоговый) режим, выполнение сценариев, организация ввода-вывода. Переменные shell (в т.ч. области видимости, экспорт), типы данных. Управление выполнением сценария shell (переходы, ветвления, циклы). Арифметические и логические операции в shell. Управление выполнением внешних программ, взаимодействие с процессами и системой в сценариях shell.

Сценарий (скрипт) оболочки представляет собой текстовый файл, который задает выполнение последовательности действий. Сценарий может содержать любую последовательность команд (как внутренних команд оболочки, так и внешних команд UNIX, с аргументами или без них), вызовов программ или других написанных ранее сценариев. Про Shell можно сказать, что это и программа и язык программирования. Работа пользователя в командной сроке ничем не отличается от выполнения длинного запутанного скрипта. Механизм работы скрипта: при запуске скрипта из командной строки запускается копия интерпретатора, для которого вводом служит скрипт (как-будто пользователь сам вводил эти команды).

##  Структура скриптов

* '#' - то, что следует за ним(в том числе и другие #), является комментарием. Комментарии могут занимать всю строку или следовать за командой.
* \ - обозначает, что строка продолжится на следующей строке файла.
* Можно записать несколько команд в 1 строку, разделенных ; .

## Переменные

Значение переменной - строка, которая передается присваиванием. V1 = 5; v2 = "string" 1 Переменной также можно присваивать значение, которое возвращается командой. V3 = `pwd`

Получение значения

* $имя_переменной - в это место подставляется значение переменной.
* $(имя_переменной) - отделяем переменную от последующих символов.


В shell существует ряд предопределенных переменных:

* HOME - домашний каталог пользователя
* PATH - путь поиска исполняемых программ
* MAIL - полное имя файла с почтой пользователя
* PS1,PS2 - первичное и вторичное приглашение shell (Значок $, который пишется в примерах - это первичное приглашение).

В shell существует ряд переменных, которые определяются оболочкой по ходу выполнения скриптов. Это так называемые встроенные переменные:

1. $0, $1, $2, ... ,$9 значения параметров, передаваемых скрипту из командной строки.
2. $0 - имя самого скрипта.
3. $# - число параметров, переданных скрипту;
4. $* - все параметры, переданные скрипту. Представляют собой единое слово, заключенное в кавычки. Существуют три вида кавычек при присваивании переменных:
    * ' ' - непосредственная подстановка, например: v4='$v1' присвоит $v1, а не 5.
    * " " - подстановка после интерпретации символов \ и $. Например: v5=$v1. Переменной v5 присвоится 5. Записи без подстановочных символов эквивалентны. даст одинаковый результат. Кавычки одного вида экранируют другие.
    * ` ` - выполнение команды внутри скобок. Результат выполнения команды будет присвоен переменной.

По умолчанию все переменные локальны, то есть существуют, пока выполняется скрипт. Чтобы сделать их глобальными (для данного shell), надо задать их при помощи export. например: export v1 При выводе неопределенных переменных результатом будет пустая строка. Для удаления переменной используется unset список_переменных. Пример: $ unset $v1 $v3 $v4 Команда set выводит список всех установленных переменных shell.

## Перенаправление ввода/вывода

Каждая программы, запущенная из shell, получает три открытых потока ввода/вывода, которые по умолчанию ассоциируются с терминалом.

Потоки задаются номерами(дескрипторы):

* 0 стандартный поток ввода, ассоциируется с клавиатурой
* 1 стандартный поток вывода, ассоциируется с экраном
* 2 стандартный поток ошибок, ассоциируется с экраном

Большинство утилит Unix используют только стандартные потоки, поэтому для этих утилит можно осуществлять перенаправление.

Виды перенаправления

* >file - поток вывода перенаправляется в файл. Пример: cat file1>file2
* >>file - данные из потока вывода добавляются в файл.
* <file - получение данных для стандартного ввода из файла.
* p1|p2 - передача вывода программы р1 на ввод программы р2 (конвейер или неименованный канал). Пример: cat spisok | wc l
* n>file - переключение потока с номером n в файл.
* n>>file - переключение потока с дескриптором n в файл, но данные добавляются в конец файла.
* n>&m - объединить потоки с дескрипторами n и m.
* <<str - конструкция "Ввод здесь". Использует стандартный поток ввода до появления строки str во вводе и потом передает его на вход программе.

## Шаблоны(wildcard's, подстановочные символы)

Оболочка позволяет делать подстановку имен. Подстановочный символ заменяется оболочкой на имена файлов, если что-то в каталоге подходит под шаблон. Это полезно в случаях, когда файлов много или необходимо выбрать несколько файлов по определенному правилу.

* * - заменяет любое количество символов (может быть и 0) , в имени файла.
* ? - заменяет любой символ в имени файла.
* [символы] - задает любой символ из диапазона.[a-c1-3] тоже что и [abc123]
* \с - задает символ с буквально (экранирует) , если с это спецсимвол(\,',",`,# и т.д.).

## Условное выполнение команд

Следующая удобная возможность - условное выполнение. Его суть такова: пусть ваши действия зависят от результата выполнения предыдущих. Выше уже упоминался разделитель команд ';' (см. 3.2.1). Но при использовании ';' последовательность команд всегда выполниться, вне зависимости от результатов работы отдельных команд (ошибок в них).
Для повышения гибкости работы, в Bourne Shell существуют следующие конструкции:

* p1&&p2 выполняется р1, если удачно (код возврата 03 ), то запускается р2
* p1||p2 - выполняется р1, если неудачно (код возврата не 0), то запускается р2
* p1& - р1 выполняется в фоновом режиме, и shell не ждет окончания работы р1 (см. ??, Контроль заданий). Оболочка сразу выводит приглашение на ввод.
* (p1;p2;) - команды выполняются последовательно в новой оболочке.
* {p1;p2;} - команды выполняются последовательно в текущей shell.

### Условные выражения

Синтаксис

if условие

then

else

fi

В shell true (0) и false (не 0) имеют обратные значения по сравнению с Си..

Условные выражения можно записывать в строчку, разделяя ;. Условием может быть результат команды. Часто используется test с параметрами.

#### Сравнение строк

* строка1 = строка2 проверка на равенство
* строка1 != строка2 проверка на не равно

#### Сравнение чисел

Аргументами являются $x(значение переменной) или число:

1. $x eq $y true, если аргументы равны
2. $x ne $y true, если аргументы не равны
3. $x gt $y true, если значение x больше значения y
4. $x ge $y true, если значение x больше либо равно значению y

#### Сложные выражения

1. !выражение - отрицание
2. выражение1 a выражение2 - логическое И
3. выражение1 o выражение2 - логическое ИЛИ

## Циклы

В языке shell есть несколько видов циклов. Часто употребимые из них:for, while .

Цикл for выполниться столько раз, сколько слов в списке. var последовательно принимает значения из списка. Список может формироваться вручную, как вывод команды (`команда`) или с помощью шаблонов.

for переменная in список

do

....

done


Цикл while выполняется, пока условие не станет ложным.

while условие

do

...

done

Для упорядочивания скрипта пользователь может определить функцию:

имя_функции ()

{

команды

}

Синтаксис и передача аргументов - как у скрипта.

## Выполнение арифметических операций

Важное замечание. В shell выполняется только целочисленная арифметика

еxpr строка преобразует строку в число. Например: expr 23. Выполняются операции: +, -, *, /, % (деление по модулю). Их приоритет обычный.

Для плавающей точки и сложных вычислений можно использовать программу bc


Примеры:

1)a = `expr $a + 3`

2)b = `expr 2 \* 3` - символ \ отменяет специальное значение *.