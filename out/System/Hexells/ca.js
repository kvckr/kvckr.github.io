const vs_code="\n    attribute vec4 position;\n    varying vec2 uv;\n    void main() {\n        uv = position.xy*0.5 + 0.5;\n        gl_Position = position;\n    }\n";function defInput(e){return`\n        uniform Tensor ${e};\n        uniform sampler2D ${e}_tex;\n\n        vec4 ${e}_read(vec2 pos, float ch) {return _read(${e}, ${e}_tex, pos, ch);}\n        vec4 ${e}_read01(vec2 pos, float ch) {return _read01(${e}, ${e}_tex, pos, ch);}\n        vec4 ${e}_readUV(vec2 uv) {return _readUV(${e}, ${e}_tex, uv);}\n    `}const PREFIX=`\n    #extension GL_OES_standard_derivatives : enable\n    precision highp float;\n\n    const float PI = 3.14159265359;\n\n    // "Hash without Sine" by David Hoskins (https://www.shadertoy.com/view/4djSRW)\n    float hash13(vec3 p3) {\n      p3  = fract(p3 * .1031);\n      p3 += dot(p3, p3.yzx + 33.33);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n    vec2 hash23(vec3 p3)\n    {\n        p3 = fract(p3 * vec3(.1031, .1030, .0973));\n        p3 += dot(p3, p3.yzx+33.33);\n        return fract((p3.xx+p3.yz)*p3.zy);\n    }\n\n    struct Tensor {\n        vec2 size;\n        vec2 gridSize;\n        float depth, depth4;\n        vec2 packScaleZero;\n    };\n    uniform Tensor u_output;\n\n    vec4 _readUV(Tensor tensor, sampler2D tex, vec2 uv) {\n        vec4 v = texture2D(tex, uv);\n        vec2 p = tensor.packScaleZero;\n        v = (v-p.y)*p.x;\n        return v;\n    }\n    vec2 _getUV(Tensor tensor, vec2 pos, float ch) {\n        ch += 0.5;\n        float tx = floor(mod(ch, tensor.gridSize.x));\n        float ty = floor(ch / tensor.gridSize.x);\n        vec2 p = fract(pos/tensor.size) + vec2(tx, ty);\n        p /= tensor.gridSize;\n        return p;\n    }\n    vec4 _read01(Tensor tensor, sampler2D tex, vec2 pos, float ch) {\n        return texture2D(tex, _getUV(tensor, pos, ch));\n    }\n    vec4 _read(Tensor tensor, sampler2D tex, vec2 pos, float ch) {\n        vec2 p = _getUV(tensor, pos, ch);\n        return _readUV(tensor, tex, p);\n    }\n    vec2 getOutputXY() {\n        return mod(gl_FragCoord.xy, u_output.size);\n    }\n    float getOutputChannel() {\n        vec2 xy = floor(gl_FragCoord.xy/u_output.size);\n        return xy.y*u_output.gridSize.x+xy.x;\n    }\n\n    void setOutput(vec4 v) {\n        vec2 p = u_output.packScaleZero;\n        v = v/p.x + p.y;\n        gl_FragColor = v;\n    }\n\n    #ifdef SPARSE_UPDATE\n        uniform sampler2D u_shuffleTex, u_unshuffleTex;\n        uniform vec2 u_shuffleOfs;\n    #endif\n\n    ${defInput("u_input")}\n\n    uniform float u_angle, u_alignment;\n    const float u_hexGrid = 1.0;\n\n    mat2 rotate(float ang) {\n        float s = sin(ang), c = cos(ang);\n        return mat2(c, s, -s, c);\n    }\n\n    vec2 ang2vec(float a) {\n        return vec2(cos(a), sin(a));\n    }\n\n    ${defInput("u_alignTex")}\n    vec2 getCellDirection(vec2 xy) {\n        return u_alignTex_read(xy, 0.0).xy;\n    }\n\n    vec4 conv3x3(vec2 xy, float inputCh, mat3 filter) {\n        vec4 a = vec4(0.0);\n        for (int y=0; y<3; ++y)\n        for (int x=0; x<3; ++x) {\n          vec2 p = xy+vec2(float(x-1), float(y-1));\n          a += filter[y][x] * u_input_read(p, inputCh);\n        }\n        return a;\n    }\n\n    // https://www.shadertoy.com/view/Xljczw\n    // https://www.shadertoy.com/view/MlXyDl\n    // returns xy - in cell pos, zw - skewed cell id\n    vec4 getHex(vec2 u) {\n        vec2 s = vec2(1., mix(2.0, 1.732, u_hexGrid));\n        vec2 p = vec2(0.5*u_hexGrid, 0.5);\n        vec2 a = mod(u    ,s)*2.-s;\n        vec2 b = mod(u+s*p,s)*2.-s;\n        vec2 ai = floor(u/s);\n        vec2 bi = floor(u/s+p);\n        // skewed coords\n        ai = vec2(ai.x-ai.y*u_hexGrid, ai.y*2.0+1.0);\n        bi = vec2(bi.x-bi.y*u_hexGrid, bi.y*2.0);\n        return dot(a,a)<dot(b,b) ? vec4(a, ai) : vec4(b, bi);\n    }\n\n    float hex(in vec2 p){\n        vec2 s = vec2(1., 1.732);\n        p = abs(p);\n        return max(dot(p, s*.5), p.x); // Hexagon.\n    }\n\n    // https://www.shadertoy.com/view/XtXcWs\n    vec2 cmul(vec2 a, vec2 b) {\n        return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n    }\n\n    vec2 cdiv(vec2 a, vec2 b) {\n        return cmul(a, vec2(b.x, -b.y)) / dot(b, b);\n    }\n\n    uniform vec2 u_viewSize;\n\n    struct Hexel {\n        vec2 cellXY;\n        vec2 p;\n        float zoom;\n    };\n\n    Hexel screen2hex(vec2 xy) {\n        xy /= u_viewSize;\n        xy.y = 1.0-xy.y;\n        vec2 normViewSize = u_viewSize/length(u_viewSize);\n        xy = (xy*0.85+0.25) * normViewSize;\n\n        Hexel h;\n        float nxy = length(xy);\n        h.zoom = 4.0/(nxy*nxy);\n        xy = cmul(xy, xy);\n        xy = cmul(xy, xy);\n        xy *= 160.0;\n        vec4 r = getHex(xy);\n        h.cellXY = r.zw;\n        h.p = r.xy;\n        return h;\n    }\n\n    float calcMouseDist(vec2 mousePosScr) {\n        Hexel h = screen2hex(mousePosScr);\n        h.cellXY = mod(h.cellXY, u_output.size);\n        vec2 diff = abs(getOutputXY()-h.cellXY-0.5);\n        return length(min(diff, u_output.size-diff))*h.zoom;\n    }\n`,PROGRAMS={paint:"\n    uniform vec2 u_pos;\n    uniform float u_r;\n    uniform vec4 u_brush;\n\n    void main() {\n        if (u_r>0.0 && calcMouseDist(u_pos)>=80.0)\n          discard;\n        setOutput(u_brush);\n    }",peek:"\n    uniform vec2 u_pos;\n\n    vec2 getPeekPos(float i) {\n        float a = i*0.61803398875*2.0*PI;\n        float r = (u_viewSize.x+u_viewSize.y)/1000.0;\n        return vec2(cos(a), sin(a)) * sqrt(i) * r;\n    }\n\n    void main() {\n        float out_i = getOutputXY().x;\n        float i = floor(out_i / u_input.depth4);\n        float channel = floor(mod(out_i, u_input.depth4));\n        Hexel h = screen2hex(u_pos + getPeekPos(i));\n        setOutput(u_input_read(h.cellXY, channel));\n    }",align:"\n    uniform vec2 u_pos;\n    uniform float u_r;\n    uniform float u_init;\n\n    const mat3 blur = mat3(1.0/9.0);\n    const mat3 blurHex = mat3(0.0,       1.0, 1.0,\n                                       1.0, 1.0, 1.0,\n                                          1.0, 1.0,        0.0)/7.0;\n\n    void main() {\n        vec2 xy = getOutputXY();\n        vec4 v = conv3x3(xy, 0.0, blur*(1.0-u_hexGrid) + blurHex*u_hexGrid);\n        v.xy = normalize(mix(u_input_read(xy, 0.0).xy, v.xy, 1.0));\n        setOutput(v);\n\n        if (u_init > 0.0) {\n            if (u_r>0.0 && calcMouseDist(u_pos)>=80.0)\n              return;\n            float a = hash13(vec3(xy+vec2(34299.0, -56593.0), u_init)) * 2.0 * PI;\n            vec2 v = normalize(ang2vec(a)+0.2*ang2vec(u_init));\n            setOutput(vec4(v, 0.0, 0.0));\n        }\n    }",perception:"\n    const mat3 sobelX = mat3(-1.0, 0.0, 1.0, -2.0, 0.0, 2.0, -1.0, 0.0, 1.0)/8.0;\n    const mat3 sobelY = mat3(-1.0,-2.0,-1.0, 0.0, 0.0, 0.0, 1.0, 2.0, 1.0)/8.0;\n    const mat3 gauss = mat3(1.0, 2.0, 1.0, 2.0, 4.0-16.0, 2.0, 1.0, 2.0, 1.0)/8.0;\n    const mat3 sobelXhex = mat3( 0.0,    -1.0, 1.0,\n                                       -2.0, 0.0, 2.0,\n                                         -1.0, 1.0,        0.0)/8.0;\n\n    const mat3 sobelYhex = mat3( 0.0,    -2.0,-2.0,\n                                        0.0, 0.0, 0.0,\n                                          2.0, 2.0,        0.0)/8.0;\n\n    const mat3 gaussHex = mat3(0.0,       2.0, 2.0,\n                                       2.0, 4.0-16.0, 2.0,\n                                          2.0, 2.0,        0.0)/8.0;\n\n    void main() {\n        vec2 xy = getOutputXY();\n        #ifdef SPARSE_UPDATE\n            xy = texture2D(u_shuffleTex, xy/u_output.size).xy*255.0+0.5 + u_shuffleOfs;\n            xy = mod(xy, u_input.size);\n        #endif\n        float ch = getOutputChannel();\n        if (ch >= u_output.depth4)\n            return;\n\n        float filterBand = floor((ch+0.5)/u_input.depth4);\n        float inputCh = ch-filterBand*u_input.depth4;\n        if (filterBand < 0.5) {\n            setOutput(u_input_read(xy, inputCh));\n        } else if (filterBand < 2.5) {\n            vec4 dx = conv3x3(xy, inputCh, sobelX*(1.0-u_hexGrid) + sobelXhex*u_hexGrid);\n            vec4 dy = conv3x3(xy, inputCh, sobelY*(1.0-u_hexGrid) + sobelYhex*u_hexGrid);\n            vec2 dir = getCellDirection(xy);\n            float s = dir.x, c = dir.y;\n            setOutput(filterBand < 1.5 ? dx*c-dy*s : dx*s+dy*c);\n        } else {\n            setOutput(conv3x3(xy, inputCh, gauss*(1.0-u_hexGrid) + gaussHex*u_hexGrid));\n        }\n    }",dense:`\n    ${defInput("u_control")}\n    uniform sampler2D u_weightTex;\n    uniform float u_seed, u_fuzz;\n    uniform vec2 u_weightCoefs; // scale, center\n    uniform vec2 u_layout;\n\n    const float MAX_PACKED_DEPTH = 32.0;\n\n    vec4 readWeightUnscaled(vec2 p) {\n        vec4 w = texture2D(u_weightTex, p);\n        return w-u_weightCoefs.y;\n    }\n\n    void main() {\n      vec2 xy = getOutputXY();\n      float ch = getOutputChannel();\n      if (ch >= u_output.depth4)\n          return;\n\n      float dy = 1.0/(u_input.depth+1.0)/u_layout.y;\n      vec2 p = vec2((ch+0.5)/u_output.depth4, dy*0.5);\n      vec2 fuzz = (hash23(vec3(xy, u_seed+ch))-0.5)*u_fuzz;\n\n      vec2 realXY = xy;\n      #ifdef SPARSE_UPDATE\n        realXY = texture2D(u_shuffleTex, xy/u_output.size).xy*255.0+0.5 + u_shuffleOfs;\n      #endif\n      float modelIdx = u_control_read(realXY+fuzz, 0.0).x+0.5;\n      p.x += floor(mod(modelIdx, u_layout.x));\n      p.y += floor(modelIdx/u_layout.x);\n      p /= u_layout;\n      vec4 result = vec4(0.0);\n      for (float i=0.0; i < MAX_PACKED_DEPTH; i+=1.0) {\n          vec4 inVec = u_input_read(xy, i);\n          result += inVec.x * readWeightUnscaled(p); p.y += dy;\n          result += inVec.y * readWeightUnscaled(p); p.y += dy;\n          result += inVec.z * readWeightUnscaled(p); p.y += dy;\n          result += inVec.w * readWeightUnscaled(p); p.y += dy;\n          if (i+1.5>u_input.depth4) {\n              break;\n          }\n      }\n      result += readWeightUnscaled(p);  // bias\n      setOutput(result*u_weightCoefs.x);\n    }`,update:`\n    ${defInput("u_update")}\n    uniform float u_seed, u_updateProbability;\n\n    varying vec2 uv;\n\n    void main() {\n      vec2 xy = getOutputXY();\n      vec4 state = u_input_readUV(uv);\n      vec4 update = vec4(0.0);\n      #ifdef SPARSE_UPDATE\n        vec4 shuffleInfo = texture2D(u_unshuffleTex, fract((xy-u_shuffleOfs)/u_output.size));\n        if (shuffleInfo.z > 0.5) {\n            update = u_update_read(shuffleInfo.xy*255.0+0.5, getOutputChannel());\n        }\n      #else\n        if (hash13(vec3(xy, u_seed)) <= u_updateProbability) {\n            update = u_update_readUV(uv);\n        }\n      #endif\n      setOutput(state + update);\n    }`,vis:"\n    uniform float u_raw;\n    uniform float u_zoom;\n    uniform float u_perceptionCircle, u_arrows;\n    uniform float u_devicePixelRatio;\n\n    varying vec2 uv;\n\n    float clip01(float x) {\n        return min(max(x, 0.0), 1.0);\n    }\n\n    float peak(float x, float r) {\n        float y = x/r;\n        return exp(-y*y);\n    }\n\n    float getElement(vec4 v, float i) {\n        if (i<1.0) return v.x;\n        if (i<2.0) return v.y;\n        if (i<3.0) return v.z;\n        return v.w;\n    }\n\n    vec3 onehot3(float i) {\n        if (i<1.0) return vec3(1.0, 0.0, 0.0);\n        if (i<2.0) return vec3(0.0, 1.0, 0.0);\n        return vec3(0.0, 0.0, 1.0);\n    }\n\n    float sdTriangleIsosceles( in vec2 p, in vec2 q ) {\n        p.x = abs(p.x);\n        vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n        vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n        float s = -sign( q.y );\n        vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                      vec2( dot(b,b), s*(p.y-q.y)  ));\n        return -sqrt(d.x)*sign(d.y);\n    }\n\n    float aastep(float v) {\n        return clip01(v/fwidth(v)/u_devicePixelRatio);\n    }\n\n    float smoothstep(float t) {\n        t = clip01(t);\n        return t * t * (3.0 - 2.0 * t);\n    }\n\n    void spot(vec2 pos, float v, vec2 xy, inout vec3 rgb) {\n        v = sqrt(abs(v))*sign(v);\n        pos *= v*0.6;\n        float r = abs(v)*0.30;\n        rgb += clip01((r-length(xy-pos))/r)*0.2;\n    }\n\n    float sdBox( in vec2 p, in vec2 b )\n    {\n        vec2 d = abs(p)-b;\n        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    }\n\n    void main() {\n        vec2 xy = vec2(uv.x, 1.0-uv.y);\n        if (u_raw > 0.5) {\n            gl_FragColor = texture2D(u_input_tex, xy);\n            gl_FragColor.a = 1.0;\n        } else {\n            vec2 screenPos = xy*u_viewSize;\n            Hexel h = screen2hex(screenPos);\n            vec2 p = h.p;\n            h.cellXY += 0.5;\n\n            vec3 rgb = u_input_read(h.cellXY, 0.0).rgb/2.0+0.5;\n            if (4.0<h.zoom) {\n                vec2 dir = getCellDirection(floor(h.cellXY)+0.5);\n                float s = dir.x, c = dir.y;\n                float fade = clip01((h.zoom-4.0)/4.0);\n                float r = clip01((1.0-hex(p))*8.0);\n                r = pow(r, 0.2);\n                rgb *= mix(1.0, r, fade);\n\n                p = mat2(c, s, -s, c) * p;\n\n                if (12.0 < h.zoom) {\n                    float da = PI/12.0;\n                    float a = -da;\n                    vec4 v4;\n                    vec3 spots;\n                    for (float ch=0.0; ch<2.5; ++ch) {\n                        v4 = (u_input_read01(h.cellXY, ch)-127.0/255.0)*2.0;\n                        spot(ang2vec(a+=da), v4.x, p, spots);\n                        spot(ang2vec(a+=da), v4.y, p, spots);\n                        spot(ang2vec(a+=da), v4.z, p, spots);\n                        spot(ang2vec(a+=da), v4.w, p, spots);\n                    }\n                    spots *= clip01((h.zoom-12.0)/3.0);\n                    rgb += spots;\n                }\n            }\n            gl_FragColor = vec4(rgb, 1.0);\n        }\n    }"};function createPrograms(e,n){n=n||"";const t={};for(const i in PROGRAMS){const r=n+PREFIX+PROGRAMS[i],s=twgl.createProgramInfo(e,[vs_code,r]);s.name=i,t[i]=s}return t}function createTensor(e,n,t,i,r){const s=Math.ceil(i/4),o=Math.ceil(Math.sqrt(s)),u=Math.floor((s+o-1)/o),a=n*o,c=t*u,l=[{minMag:e.NEAREST}],h=twgl.createFramebufferInfo(e,l,a,c);return{_type:"tensor",fbi:h,w:n,h:t,depth:i,gridW:o,gridH:u,depth4:s,tex:h.attachments[0],packScaleZero:r}}function setTensorUniforms(e,n,t){e[n+".size"]=[t.w,t.h],e[n+".gridSize"]=[t.gridW,t.gridH],e[n+".depth"]=t.depth,e[n+".depth4"]=t.depth4,e[n+".packScaleZero"]=t.packScaleZero,"u_output"!=n&&(e[n+"_tex"]=t.tex)}function decodeBase64(e){const n=atob(e),t=new Uint8Array(n.length);for(let e=0;e<n.length;e++)t[e]=n.charCodeAt(e);return t}function createDenseInfo(e,n,t){const i=[n.scale,127/255],[r,s]=n.shape,o={coefs:i,layout:n.layout,in_n:r-1,out_n:s,quantScaleZero:n.quant_scale_zero,ready:!1},u=UPNG.decode(decodeBase64(n.data.split(",")[1])),a=new Uint8Array(UPNG.toRGBA8(u)[0]);return o.tex=twgl.createTexture(e,{width:u.width,height:u.height,minMag:e.NEAREST,src:a},(()=>{})),setTimeout((()=>{o.ready=!0,t()}),0),o}class CA{constructor(e,n,t,i){this.onready=i||(()=>{}),this.gl=e,this.gridSize=t||[96,96],e.getExtension("OES_standard_derivatives"),this.updateProbability=.5,this.shuffledMode=!0,this.rotationAngle=0,this.alignment=1,this.fuzz=8,this.perceptionCircle=0,this.arrowsCoef=0,this.visMode="color",this.hexGrid=1,this.devicePixelRatio=globalThis.devicePixelRatio||1,this.layers=[],this.setWeights(n),this.progs=createPrograms(e,this.shuffledMode?"#define SPARSE_UPDATE\n":""),this.quad=twgl.createBufferInfoFromArrays(e,{position:[-1,-1,0,1,-1,0,-1,1,0,-1,1,0,1,-1,0,1,1,0]}),this.setupBuffers();Object.getOwnPropertyNames(this.buf).push("color"),this.clearCircle(0,0,-1),this.disturb()}disturb(){this.runLayer(this.progs.align,this.buf.align,{u_input:this.buf.newAlign,u_hexGrid:this.hexGrid,u_init:1e3*Math.random()+1,u_r:-1})}disturbCircle(e,n,t,i){i=i||[128,128],this.runLayer(this.progs.align,this.buf.align,{u_input:this.buf.newAlign,u_hexGrid:this.hexGrid,u_init:1e3*Math.random()+1,u_pos:[e,n],u_r:t,u_viewSize:i})}setupBuffers(){const e=this.gl,[n,t]=this.gridSize,i=Math.ceil(t*this.updateProbability),r=i*n,s=n*t,o=new Uint8Array(4*r),u=new Uint8Array(4*s);let a=0;for(let e=0;e<s;++e)Math.random()<(r-a)/(s-e)&&(o[4*a+0]=e%n,o[4*a+1]=Math.floor(e/n),u[4*e+0]=a%n,u[4*e+1]=Math.floor(a/n),u[4*e+2]=255,a+=1);this.shuffleTex=twgl.createTexture(e,{minMag:e.NEAREST,width:n,height:i,src:o}),this.unshuffleTex=twgl.createTexture(e,{minMag:e.NEAREST,width:n,height:t,src:u}),this.shuffleOfs=[0,0];const c=this.shuffledMode?i:t,l=this.layers[0].in_n,h=this.layers[this.layers.length-1],f=h.out_n;this.channel_n=f;const p=h.quantScaleZero;this.buf={control:createTensor(e,n,t,4,[255,0]),align:createTensor(e,n,t,4,[2,127/255]),newAlign:createTensor(e,n,t,4,[2,127/255]),state:createTensor(e,n,t,f,p),newState:createTensor(e,n,t,f,p),perception:createTensor(e,n,c,l,p),sonic:createTensor(e,16*f/4,1,4,p)};{const{width:e,height:n}=this.buf.sonic.fbi;this.sonicBuf=new Uint8Array(n*e*4)}for(let t=0;t<this.layers.length;++t){const i=this.layers[t];this.buf[`layer${t}`]=createTensor(e,n,c,i.out_n,i.quantScaleZero)}}step(e){if(e=e||"all",!this.layers.every((e=>e.ready)))return;if("all"==e){const[e,n]=this.gridSize;this.shuffleOfs=[Math.floor(Math.random()*e),Math.floor(Math.random()*n)]}"all"!=e&&"align"!=e||this.runLayer(this.progs.align,this.buf.newAlign,{u_input:this.buf.align,u_hexGrid:this.hexGrid,u_init:0}),"all"!=e&&"perception"!=e||this.runLayer(this.progs.perception,this.buf.perception,{u_input:this.buf.state,u_angle:this.rotationAngle/180*Math.PI,u_alignTex:this.buf.newAlign,u_alignment:this.alignment,u_hexGrid:this.hexGrid});let n=this.buf.perception;for(let t=0;t<this.layers.length;++t)"all"!=e&&e!=`layer${t}`||this.runDense(this.buf[`layer${t}`],n,this.layers[t]),n=this.buf[`layer${t}`];"all"!=e&&"newState"!=e||this.runLayer(this.progs.update,this.buf.newState,{u_input:this.buf.state,u_update:n,u_unshuffleTex:this.unshuffleTex,u_seed:1e3*Math.random(),u_updateProbability:this.updateProbability}),"all"==e&&([this.buf.state,this.buf.newState]=[this.buf.newState,this.buf.state],[this.buf.align,this.buf.newAlign]=[this.buf.newAlign,this.buf.align])}benchmark(){const e=this.gl,n=new Uint8Array(4),t=t=>{t=t||this.buf.state,twgl.bindFramebufferInfo(e,t.fbi),e.readPixels(0,0,1,1,e.RGBA,e.UNSIGNED_BYTE,n)};t();const i=100,r=Date.now();for(let e=0;e<i;++e)this.step();t();const s=(Date.now()-r)/i,o=["align","perception"];for(let e=0;e<this.layers.length;++e)o.push(`layer${e}`);o.push("newState");let u=0;const a=[];for(const e of o){const n=Date.now();for(let n=0;n<i;++n)this.step(e);t(this.buf[e]);const r=(Date.now()-n)/i;u+=r,a.push([e,r])}const c=a.map((e=>{const[n,t]=e;return`${n}: ${(100*t/u).toFixed(1)}%`})).join(", ");return`${s.toFixed(2)} ms/step, ${(1e3/s).toFixed(2)} step/sec\n`+c+"\n\n"}paint(e,n,t,i,r){r=r||[128,128],this.runLayer(this.progs.paint,this.buf.control,{u_pos:[e,n],u_r:t,u_brush:[i,0,0,0],u_viewSize:r})}peek(e,n,t){this.runLayer(this.progs.peek,this.buf.sonic,{u_pos:[e,n],u_viewSize:t,u_input:this.buf.state});const{width:i,height:r}=this.buf.sonic.fbi,s=this.gl;return twgl.bindFramebufferInfo(s,this.buf.sonic.fbi),s.readPixels(0,0,i,r,s.RGBA,s.UNSIGNED_BYTE,this.sonicBuf),{buf:this.sonicBuf,tex:this.buf.sonic.tex,pos:[e,n]}}clearCircle(e,n,t,i){i=i||[128,128],this.runLayer(this.progs.paint,this.buf.state,{u_pos:[e,n],u_r:t,u_brush:[0,0,0,0],u_viewSize:i})}setWeights(e){const n=this.gl;this.layers.forEach((e=>n.deleteTexture(e)));const t=()=>{this.layers.every((e=>e.ready))&&this.onready()};this.layers=e.layers.map((e=>createDenseInfo(n,e,t)))}runLayer(e,n,t){const i=this.gl;t=t||{};const r={};for(const e in t){const n=t[e];"tensor"==n._type?setTensorUniforms(r,e,n):r[e]=n}return r.u_shuffleTex=this.shuffleTex,r.u_shuffleOfs=this.shuffleOfs,setTensorUniforms(r,"u_output",n),twgl.bindFramebufferInfo(i,n.fbi),i.useProgram(e.program),twgl.setBuffersAndAttributes(i,e,this.quad),twgl.setUniforms(e,r),twgl.drawBufferInfo(i,this.quad),{programName:e.name,output:n}}runDense(e,n,t){return this.runLayer(this.progs.dense,e,{u_input:n,u_control:this.buf.control,u_weightTex:t.tex,u_weightCoefs:t.coefs,u_layout:t.layout,u_seed:1e3*Math.random(),u_fuzz:this.fuzz})}draw(e,n){n=n||this.visMode;const t=this.gl;t.useProgram(this.progs.vis.program),twgl.setBuffersAndAttributes(t,this.progs.vis,this.quad);const i={u_raw:0,u_angle:this.rotationAngle/180*Math.PI,u_alignment:this.alignment,u_perceptionCircle:this.perceptionCircle,u_arrows:this.arrowsCoef,u_devicePixelRatio:this.devicePixelRatio,u_viewSize:e};let r=this.buf.state;"color"!=n&&(r=this.buf[n],i.u_raw=1),setTensorUniforms(i,"u_input",r),setTensorUniforms(i,"u_alignTex",this.buf.align),twgl.setUniforms(this.progs.vis,i),twgl.drawBufferInfo(t,this.quad)}}