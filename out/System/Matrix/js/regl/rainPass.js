import{loadImage,loadText,makeDoubleBuffer,makePass,makePassFBO}from"./utils.js";const extractEntries=(e,r)=>Object.fromEntries(Array.from(Object.entries(e)).filter((([e])=>r.includes(e)))),rippleTypes={box:0,circle:1},makeComputeDoubleBuffer=(e,r,t)=>makeDoubleBuffer(e,{width:t,height:r,wrapT:"clamp",type:"half float"}),numVerticesPerQuad=6,tlVert=[0,0],trVert=[0,1],blVert=[1,0],brVert=[1,1],quadVertices=[tlVert,trVert,brVert,tlVert,brVert,blVert];export default({regl:e,config:r,lkg:t})=>{const a=r.volumetric,s=a&&"none"!==r.effect?r.density:1,[l,o]=[r.numColumns,Math.floor(r.numColumns*s)],[i,n]=a?[l,o]:[1,1],f=i*n,p=[1/n,1/i],u=r.rippleTypeName in rippleTypes?rippleTypes[r.rippleTypeName]:-1,m=[Math.cos(r.slant),Math.sin(r.slant)],d=1/(Math.abs(Math.sin(2*r.slant))*(Math.sqrt(2)-1)+1),c="none"===r.effect,g={...extractEntries(r,["animationSpeed","glyphHeightToWidth","glyphSequenceLength","glyphTextureGridSize"]),numColumns:o,numRows:l,showDebugView:c},h=makeComputeDoubleBuffer(e,1,o),b=loadText("shaders/glsl/rainPass.intro.frag.glsl"),x={...g,...extractEntries(r,["fallSpeed","skipIntro"])},S=e({frag:e.prop("frag"),uniforms:{...x,previousIntroState:h.back},framebuffer:h.front}),y=makeComputeDoubleBuffer(e,l,o),T=loadText("shaders/glsl/rainPass.raindrop.frag.glsl"),M={...g,...extractEntries(r,["brightnessDecay","fallSpeed","raindropLength","loops","skipIntro"])},V=e({frag:e.prop("frag"),uniforms:{...M,introState:h.front,previousRaindropState:y.back},framebuffer:y.front}),P=makeComputeDoubleBuffer(e,l,o),k=loadText("shaders/glsl/rainPass.symbol.frag.glsl"),v={...g,...extractEntries(r,["cycleSpeed","cycleFrameSkip","loops"])},C=e({frag:e.prop("frag"),uniforms:{...v,raindropState:y.front,previousSymbolState:P.back},framebuffer:P.front}),D=makeComputeDoubleBuffer(e,l,o),w=loadText("shaders/glsl/rainPass.effect.frag.glsl"),I={...g,...extractEntries(r,["hasThunder","rippleScale","rippleSpeed","rippleThickness","loops"]),rippleType:u},B=e({frag:e.prop("frag"),uniforms:{...I,raindropState:y.front,previousEffectState:D.back},framebuffer:D.front}),E=Array(i).fill().map(((e,r)=>Array(n).fill().map(((e,t)=>Array(6).fill([t,r]))))),F=loadImage(e,r.glyphMSDFURL),z=loadImage(e,r.glintMSDFURL),R=loadImage(e,r.baseTextureURL),q=loadImage(e,r.glintTextureURL),A=loadText("shaders/glsl/rainPass.vert.glsl"),L=loadText("shaders/glsl/rainPass.frag.glsl"),O=makePassFBO(e,r.useHalfFloat),N={...g,...extractEntries(r,["forwardSpeed","glyphVerticalSpacing","baseBrightness","baseContrast","glintBrightness","glintContrast","hasBaseTexture","hasGlintTexture","brightnessThreshold","brightnessOverride","isolateCursor","isolateGlint","glyphEdgeCrop","isPolar"]),density:s,numQuadColumns:n,numQuadRows:i,quadSize:p,slantScale:d,slantVec:m,volumetric:a},U=e({blend:{enable:!0,func:{src:"one",dst:"one"}},vert:e.prop("vert"),frag:e.prop("frag"),uniforms:{...N,raindropState:y.front,symbolState:P.front,effectState:D.front,glyphMSDF:F.texture,glintMSDF:z.texture,baseTexture:R.texture,glintTexture:q.texture,msdfPxRange:4,glyphMSDFSize:[F.width(),F.height()],glintMSDFSize:[z.width(),z.height()],camera:e.prop("camera"),transform:e.prop("transform"),screenSize:e.prop("screenSize")},viewport:e.prop("viewport"),attributes:{aPosition:E,aCorner:Array(f).fill(quadVertices)},count:6*f,framebuffer:O}),j=[1,1],{mat4:G,vec3:Q}=glMatrix,H=G.create();a&&r.isometric?(G.rotateX(H,H,1*Math.PI/8),G.rotateY(H,H,1*Math.PI/4),G.translate(H,H,Q.fromValues(0,0,-1)),G.scale(H,H,Q.fromValues(1,1,2))):t.enabled?(G.translate(H,H,Q.fromValues(0,0,-1.1)),G.scale(H,H,Q.fromValues(1,1,1)),G.scale(H,H,Q.fromValues(.15,.15,.15))):G.translate(H,H,Q.fromValues(0,0,-1));G.create();const X=[];return makePass({primary:O},Promise.all([F.loaded,z.loaded,R.loaded,q.loaded,b.loaded,T.loaded,k.loaded,A.loaded,L.loaded]),((e,s)=>{O.resize(e,s);const l=e/s,[o,i]=[t.tileX,t.tileY],n=i*o,f=Math.floor(e/o),p=Math.floor(s/i);X.length=0;for(let e=0;e<i;e++)for(let s=0;s<o;s++){const i=s+e*o,u=G.create();if(a&&r.isometric)l>1?G.ortho(u,-1.5*l,1.5*l,-1.5,1.5,-1e3,1e3):G.ortho(u,-1.5,1.5,-1.5/l,1.5/l,-1e3,1e3);else if(t.enabled){G.perspective(u,Math.PI/180*t.fov,t.quiltAspect,1e-4,1e3);const e=-1;let r=Math.PI/180*t.viewCone*(i/(n-1)-.5);isNaN(r)&&(r=0);const a=e*Math.tan(r);G.translate(u,u,Q.fromValues(a,0,0)),u[8]=-a/(e*Math.tan(Math.PI/180*.5*t.fov)*t.quiltAspect)}else G.perspective(u,Math.PI/180*90,l,1e-4,1e3);const m={x:s*f,y:e*p,width:f,height:p};X.push({camera:u,viewport:m})}[j[0],j[1]]=l>1?[1,l]:[1/l,1]}),(()=>{S({frag:b.text()}),V({frag:T.text()}),C({frag:k.text()}),B({frag:w.text()}),e.clear({depth:1,color:[0,0,0,1],framebuffer:O});for(const e of X)U({...e,transform:H,screenSize:j,vert:A.text(),frag:L.text()})}))};