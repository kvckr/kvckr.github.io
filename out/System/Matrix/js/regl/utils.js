const makePassTexture=(t,e,a)=>t.texture({width:1,height:1,type:e?"half float":"uint8",wrap:"clamp",minFilter:"mipmap",min:a?"mipmap":"linear",mag:"linear"}),makePassFBO=(t,e)=>t.framebuffer({color:makePassTexture(t,e)}),makeDoubleBuffer=(t,e)=>{const a=Array(2).fill().map((()=>t.framebuffer({color:t.texture(e),depthStencil:!1})));return{front:({tick:t})=>a[t%2],back:({tick:t})=>a[(t+1)%2]}},loadImage=(t,e)=>{let a=t.texture([[0]]),n=!1;return{texture:()=>(n||null==e||console.warn(`texture still loading: ${e}`),a),width:()=>n?a.width:1,height:()=>n?a.height:1,loaded:(async()=>{if(null!=e){const i=new Image;i.crossOrigin="anonymous",i.src=e,await i.decode(),n=!0,a=t.texture({data:i,mag:"linear",min:"linear",flipY:!0})}})()}},BASE_PATH="/System/Matrix/",loadText=t=>{let e="",a=!1;return{text:()=>(a||console.warn(`text still loading: ${t}`),e),loaded:(async()=>{null!=t&&(e=await(await fetch(`${BASE_PATH}/${t}`)).text(),a=!0)})()}},makeFullScreenQuad=(t,e={},a={})=>t({vert:"\n\t\tprecision mediump float;\n\t\tattribute vec2 aPosition;\n\t\tvarying vec2 vUV;\n\t\tvoid main() {\n\t\t\tvUV = 0.5 * (aPosition + 1.0);\n\t\t\tgl_Position = vec4(aPosition, 0, 1);\n\t\t}\n\t",frag:"\n\t\tprecision mediump float;\n\t\tvarying vec2 vUV;\n\t\tuniform sampler2D tex;\n\t\tvoid main() {\n\t\t\tgl_FragColor = texture2D(tex, vUV);\n\t\t}\n\t",attributes:{aPosition:[-4,-4,4,-4,0,4]},count:3,uniforms:{...e,time:t.context("time"),tick:t.context("tick")},context:a,depth:{enable:!1}}),make1DTexture=(t,e)=>{const a=e.map((t=>t.map((t=>Math.floor(255*t))))).flat();return t.texture({data:a,width:a.length/4,height:1,format:"rgba",mag:"linear",min:"linear"})},makePass=(t,e,a,n)=>({outputs:t??{},ready:e??Promise.resolve(),setSize:a??(()=>{}),execute:n??(()=>{})}),makePipeline=(t,e)=>e.filter((t=>null!=t)).reduce(((e,a,n)=>[...e,a(t,0==n?null:e[n-1].outputs)]),[]);export{makePassTexture,makePassFBO,makeDoubleBuffer,loadImage,loadText,makeFullScreenQuad,make1DTexture,makePass,makePipeline};